import 'package:core/core.dart';
import 'package:testing/mocks/packages.dart';
import 'package:testing/testing.dart';

part 'behaviour_test.types.dart';

void main() {
  setUpAll(() {
    registerFallbackValue(StackTrace.empty);
  });

  group(BehaviourMixin, () {
    late String fakeDescription;
    late MockLogger mockErrorLogger;
    late MockFailureGenerator mockFailureGenerator;

    late _WithBehaviourMixin behaviourMixin;

    setUp(() {
      fakeDescription = faker.lorem.sentence();

      mockErrorLogger = MockLogger();
      mockFailureGenerator = MockFailureGenerator();

      behaviourMixin = _WithBehaviourMixin(
        mockErrorLogger,
        mockFailureGenerator.call,
        fakeDescription,
      );
    });

    group('executeAction', () {
      test('should return the value of the action on success', () async {
        // arrange
        final fakeResult = Success(faker.randomObject());

        // action
        final result = await behaviourMixin.executeAction(
          () async => fakeResult,
        );

        // assert
        expect(result, fakeResult);
      });

      test('should catch exceptions', () async {
        // arrange
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(faker.failure()));

        // act
        await behaviourMixin.executeAction(() => throw faker.randomObject());

        // assert
        // if an exception was throw we would not get here ;)
      });

      group('should log the exception', () {
        test('with description', () async {
          // arrange
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));

          // act
          await behaviourMixin.executeAction(() => throw fakeError);

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened on $fakeDescription',
              fakeError,
              any(),
            ),
          );
        });

        test('without description', () async {
          // arrange
          behaviourMixin = _WithBehaviourMixin(
            mockErrorLogger,
            mockFailureGenerator.call,
            null,
          );
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));

          // act
          await behaviourMixin.executeAction(() => throw fakeError);

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened',
              fakeError,
              any(),
            ),
          );
        });
      });

      test('should return the failure generated by [onFailed] on exception',
          () async {
        // arrange
        final fakeFailure = faker.failure();
        final fakeError = faker.randomObject();
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(fakeFailure));

        // act
        final failure = await behaviourMixin.executeAction(
          () => throw fakeError,
        );

        // assert
        expect(failure, Failed(fakeFailure));
        verify(() => mockFailureGenerator(fakeError, any()));
      });
    });
  });

  group(BehaviourWithoutInput, () {
    late String fakeDescription;
    late MockLogger mockErrorLogger;
    late MockFailureGenerator mockFailureGenerator;
    late MockActionWithoutInput mockAction;

    late _BehaviourWithoutInput behaviour;

    setUp(() {
      fakeDescription = faker.lorem.sentence();

      mockErrorLogger = MockLogger();
      mockFailureGenerator = MockFailureGenerator();
      mockAction = MockActionWithoutInput();

      behaviour = _BehaviourWithoutInput(
        errorLogger: mockErrorLogger,
        failureGenerator: mockFailureGenerator.call,
        onAction: mockAction.call,
        description: fakeDescription,
      );
    });

    group('call', () {
      test('should return the value of the action on success', () async {
        // arrange
        final fakeResult = faker.randomObject();
        when(() => mockAction()).thenAnswer((i) async => fakeResult);

        // action
        final result = await behaviour();

        // assert
        expect(result, Success(fakeResult));
        verify(() => mockAction());
      });

      test('should catch exceptions', () async {
        // arrange
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(faker.failure()));
        when(() => mockAction()).thenThrow(faker.randomObject());

        // act
        await behaviour();

        // assert
        // if an exception was throw we would not get here ;)
      });

      group('should log the exception', () {
        test('with description', () async {
          // arrange
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));
          when(() => mockAction()).thenThrow(fakeError);

          // act
          await behaviour();

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened on $fakeDescription',
              fakeError,
              any(),
            ),
          );
        });

        test('without description', () async {
          // arrange
          behaviour = _BehaviourWithoutInput(
            errorLogger: mockErrorLogger,
            failureGenerator: mockFailureGenerator.call,
            onAction: mockAction.call,
            description: null,
          );
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));
          when(() => mockAction()).thenThrow(fakeError);

          // act
          await behaviour();

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened',
              fakeError,
              any(),
            ),
          );
        });
      });

      test('should return the failure generated by [onFailed]', () async {
        // arrange
        final fakeFailure = faker.failure();
        final fakeError = faker.randomObject();
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(fakeFailure));

        // act
        final failure = await behaviour.executeAction(
          () => throw fakeError,
        );

        // assert
        expect(failure, Failed(fakeFailure));
        verify(() => mockFailureGenerator(fakeError, any()));
      });
    });
  });

  group(Behaviour, () {
    late String fakeDescription;
    late MockLogger mockErrorLogger;
    late MockFailureGenerator mockFailureGenerator;
    late MockAction mockAction;

    late _Behaviour behaviour;

    setUp(() {
      fakeDescription = faker.lorem.sentence();

      mockErrorLogger = MockLogger();
      mockFailureGenerator = MockFailureGenerator();
      mockAction = MockAction();

      behaviour = _Behaviour(
        errorLogger: mockErrorLogger,
        failureGenerator: mockFailureGenerator.call,
        onAction: mockAction.call,
        description: fakeDescription,
      );
    });

    group('call', () {
      test('should return the value of the action on success', () async {
        // arrange
        final fakeResult = faker.randomObject();
        final fakeInput = faker.randomObject();
        when(() => mockAction(any())).thenAnswer((i) async => fakeResult);

        // action
        final result = await behaviour(fakeInput);

        // assert
        expect(result, Success(fakeResult));
        verify(() => mockAction(fakeInput));
      });

      test('should catch exceptions', () async {
        // arrange
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(faker.failure()));
        when(() => mockAction(any())).thenThrow(faker.randomObject());

        // act
        await behaviour(faker.randomObject());

        // assert
        // if an exception was throw we would not get here ;)
      });

      group('should log the exception', () {
        test('with description', () async {
          // arrange
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));
          when(() => mockAction(any())).thenThrow(fakeError);

          // act
          await behaviour(faker.randomObject());

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened on $fakeDescription',
              fakeError,
              any(),
            ),
          );
        });

        test('without description', () async {
          // arrange
          behaviour = _Behaviour(
            errorLogger: mockErrorLogger,
            failureGenerator: mockFailureGenerator.call,
            onAction: mockAction.call,
            description: null,
          );
          final fakeError = faker.randomObject();
          when(() => mockFailureGenerator(any(), any()))
              .thenAnswer((i) => Future.value(faker.failure()));
          when(() => mockAction(any())).thenThrow(fakeError);

          // act
          await behaviour(faker.randomObject());

          // assert
          verify(
            () => mockErrorLogger.e(
              'An error happened',
              fakeError,
              any(),
            ),
          );
        });
      });

      test('should return the failure generated by [onFailed]', () async {
        // arrange
        final fakeFailure = faker.failure();
        final fakeError = faker.randomObject();
        when(() => mockFailureGenerator(any(), any()))
            .thenAnswer((i) => Future.value(fakeFailure));

        // act
        final failure = await behaviour.executeAction(
          () => throw fakeError,
        );

        // assert
        expect(failure, Failed(fakeFailure));
        verify(() => mockFailureGenerator(fakeError, any()));
      });
    });
  });
}
